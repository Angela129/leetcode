# 单链表的反向
##  递归
### 边界：head!==null&&head.next!==null否则就找到链尾让它作表头
```
function ListNode(val){
    this.val=val
    this.next=null
}
var reverseList = function(head) {
    //递归
   function  _reverse(head){
        if(head&&head.next){
            _reverse(head.next)
            head.next.next=head
            head.next=null
        }else{
            _reverse.head=head
        }
    }
    _reverse(head)
    return _reverse.head
    
};
```
# 回文链表的检测
##  思路：找到链表的中点，反转前半段链表，和后半段链表做个比较是否一样<br />如果是单数个结点的链表，在中点选择上要注意往后错一个<br />
找中间值的时候利用快慢指针，快指针式是head一下走两个格，慢指针是mid 每次走一个格
```
var isPalindrome = function(head) {
   //链表的边界处理
    if(head===null||(head===null&&head.next===null))return true
    let mid=head
    let pre=null
    let reversed=null
    while(head!=null&&head.next!=null){
        //找到中点
        pre=mid
        head=head.next.next
        mid=mid.next
        //反转中点之前的内容
       pre.next=reversed
        reversed=pre
    }
    //如果是奇数个，mid再往后走一个。因为head每次走两步，所以如果是偶数的话应该是到最后就是null了
    if(head)mid=mid.next
    //对比反转后的和之前的两个链表一不一样
    while(mid){
        if(reversed.val!==mid.val)return false
        reversed=reversed.next
        mid=mid.next
    }
    return true
};
```
